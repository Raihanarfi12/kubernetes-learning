Kubectl command :
- kubectl config view
- kubectl proxy 
- kubectl create -f {deployment_file.yml}
- kubectl get pods
- kubectl describe pod {pod_name} --> check event that happend to pod
- kubectl get pods -o wide --> Show which node used for pod
- kubectl run {pod_name} --image={image_name} --port={port}
- kubectl run nginx-pod --image=nginx:1.22.1 --port=80 --dry-run=client -o yaml > nginx-pod.yaml (dry run to show what happend next when we run this command)
- kubectl delete pod {pod_name}
- kubectl replace --force -f {deployment_file} --> reapply deployment file, used for fix wrong or invalid template
- kubectl get replicasets (or kubectl get rs)
- kubectl get replicaset {replicaset_name} -o [yaml,json]
- kubectl run admitted --image=nginx --image-pull-policy=IfNotPresent
- kubectl run mutated --image=nginx --image-pull-policy=IfNotPresent
#Grep selector for specific service (For getting pods related to service)
- kubectl describe svc pod-hello | grep -i selector
#Grep endpoint (IP address and exposed port of pods related to service)
- kubectl get ep
#Edit service
- kubectl edit svc {name_of_service}
- kubectl port-forward deploy/frontend 8080:5000 (url can be accessed through port 8080)
- kubectl expose deployment webserver --name=web-service --type=NodePort
- kubectl create deployment webserver --image=nginx:alpine --replicas=3 --port=80
- kubectl delete deployments web-dash

Objects in kubernetes:
  - cluster --> group of nodes for kubernetes infrastructure
  - node --> can be physic machine or virtual machine
    - control plane
      - api server
      - controller manager
      - scheduler
      - kubelet
      - kube-proxy
    - worker
      - kubelet
      - kube-proxy
  - pods --> smallest unit in kubernetes
  - namespace --> sub-cluster
  - labels --> tagging for objects in kubernetes
    - selector
      - equality-based selector --> equals
      - set-based selector --> in or not in, !app (no label key app)
  - replication controller --> ensure number of replica based on desired state of application (legacy type)
    - only support equality-based selector
  - Deployment --> manage creation, update, and deletion of pods. Automatically create replicaset.
    - Support update and rolling back (RollingUpdate strategy)
    - Deploymentcontroller is part of control plane controller manager
  - Replicaset --> control lifecycle of multiple replica of pod for HA
    - support self healing
    - support equality-based and set-based selector
    - Do not support update and rolling back
  - service :
    - Group logical of pods that can be chosen by label and selector
    - Type of services :
        - ClusterIP
            - default service type
            - Can be accessed within cluster only
        - Nodeport
            - High port, dynamically picked port number from 30000-32767
            - Example, if we mapping port 32233 to frontend-svc, it will be directed to clusterIP of frontend-svc
            - Useful when port accessed from external user, and then proxied internally to clusterIP
        - LoadBalancer

  - kube-proxy
    - Daemon each cluster node, watching API server in control plane for addition, removal or update of service and endpoints
    - Build redundantly with iptables
    - Load balancing to endpoints/pods
    - If traffic policies not assigned, service will direct or routed traffic randomly for load balancing

  - Traffic Policies :
    - Make sure traffic routed based on policy / not randomly
    - Applied for internal traffic from cluster of external traffic from client
    - Type of traffic policies :
        - cluster
            - default behavior or traffic policies not assigned. Target all endpoints of services in load balancing
        - local
            - isolates number of pods or endpoints in service on same node in load balancing traffic
            - specific node that capture inbound traffic (Nodeport)
  - Service discovery
    - Environment variables
    - DNS
  - LoadBalancer
    - Nodeport and ClusterIP automatically
    - Service is exposed at a static port on each worker node
    - Service is exposed externally using cloud provided LoadBalancer
    - Only supported for automatic created load balancer and support kubernetes
  - ExternalIP
    - Can route one or multi worker nodes.
    - Traffic that is ingressed into cluster with externalIP as destination IP on service port, get routed to service endpoint
    - Require Load Balancer from cloud provider
    - Not managed by Kubernetes
  - ExternalName
    - No specific namespace and not define any endpoint
    - return CName record of an externally configured service
  - Multi port service
    - Expose many ports from any pod
    - Expose group of pods that contain many container with different port
  - Port Forwarding
    - Forward local port to application port
    - Application port can be pod port, service port, endpoint port, or deployment container port
    - Alternative to Nodeport, usually used for troubleshooting or debugging


Users in kubernetes authentication :
  - Normal Users
  - Service Account

Authentication modules :
  - X509 Client certificates
  - Static token file
  - Bootstrap token
  - Service account tokens
  - OpenID Connect tokens
  - Webhook Token Authentication
  - Authenticating proxy

Authorization modes : 
  - Node
    --> Used for authorization for kubelet to read operation to node, service, endpoint and write operation to node, service, endpoint, pods
  - Attribute Based Access Control (ABAC)
    --> Combine Attribute with policy.
    --> For specify ABAC mode ,  --authorization-mode=ABAC and --authorization-policy-file=PolicyFile.json
  - Webhook
    --> Integrate to third party
  - Role-Based Access Control (RBAC)
    - Restric based on operations or group of operations (Role), assigned to Users
    - Kind of roles
      - Role
        - Role grant to specific resources within specific namespace
      - ClusterRole
        - Same as role, but scope is cluster wide

Admission control : 
  - Specify granular Access control policies, ex : 
    - allowing priviledged container
    - checking on quota resources
    - Activated using parameter --enable-admission-plugins=NamespaceLifecycle,ResourceQuota,PodSecurity,DefaultStorageClass
  - Type of admission controllers :
    - Limitranger (Scope per individual pod or container)
      - Ensures that pods and containers have resource limits defined.
      - If LimitRange resources are defined in a namespace, LimitRanger checks whether the requests (for CPU and memory) in a pod fall within those limits.
      - If requests or limits are missing, it can set default values or deny the request if it's out of bounds.
    - ResourceQuota (Scope per namespace)
      - Enforces resource quotas in a namespace, limiting the total resource consumption for pods, services, or other Kubernetes objects within that namespace.
      - It ensures that resources (like CPU, memory, or object counts) do not exceed predefined limits.
      - If a request would exceed the quota, the admission controller denies it.
    - DefaultStorageClass
      - Ensures that persistent volume claims (PVCs) have a default storage class if none is specified.
      - When a PVC is created without specifying a storage class, the DefaultStorageClass admission controller automatically assigns the default storage class if one is available.
      - This simplifies the PVC creation process and ensures that storage is dynamically provisioned when needed.
    - AlwaysPullImages
      - Forces the imagePullPolicy of all containers to Always, regardless of what is specified in the pod specification.
      - This ensures that the latest image is always pulled from the registry, preventing accidental use of cached or old images.
      - Particularly useful in multi-tenant clusters where you want to prevent image reuse that may lead to security issues.

Liveness and Readiness Probe:
  - Liveness :
    - Used when pods still running, but application in container was issue
    - It can be caused of application deadlock or memory pressure
    - Liveness probe can help us to restart the container or application automatically based on application health
    - Can be set by:
      - Liveness command
        - Checking existence file of /tmp/healthy
      - Liveness HTTP request
        - Send HTTP GET request to /healthz of endpoint application with port 8080.
        - If failed, the kubelet will restart the container.
      - TCP Liveness probe
        - Attempts to open TCP socket to container.
        - If succeed, application considered be healthy. Otherwise, application marked as unhealthy and container will be restarted
      - gRPC Liveness probe
        - Required port to be defined
        - Optionally, use the service field to use same port with other application

  - Readiness probe
    - Ensure dependent services in ready in container before serve traffic
    - Command or template similar to liveness probe'

  - Startup probe
    - Designed for legacy application
    - Used when inizialization or startup of application take long time and used for delay the liveness and Readiness probe

Kubernetes Volume :
  - Volume
    - Storage abstraction that allow various storage technologies
    - An ephemeral volume is mount point on container file system backed by media storage
    - Ephemeral volume linked to pod
    - Volume can be shared among containers of pod
    - Type of Volume
      - emptyDir
        - tightly coupled with pod. If pod deleted or terminated, then data of emptyDir is deleted
      - hostPath
        - Shared between and host. If pod terminated, data still stored or available in host. 
      - gcePersistentDisk
      - awsElasticBlockStore
      - azureDisk
      - azureFile
      - cephfs
      - nfs
      - iscsi
      - secret
        - Supply sensitive information (password, secret, certificate, key)
      - configMap
        - Store configuration data or shell command
      - persistentVolumeClaim
        - Persistent Volume is consumed by pod using persistentVolumeClaim

  - Container Storage Interface (CSI)
    - Used for volume interface, volume plugin, designed on different container orchestrator with a variety of storage technologies

  - Persistent Volume
  - Persistent Volume Claims
