Kubectl command :
- kubectl config view
- kubectl proxy 
- kubectl create -f {deployment_file.yml}
- kubectl get pods
- kubectl describe pod {pod_name} --> check event that happend to pod
- kubectl get pods -o wide --> Show which node used for pod
- kubectl run {pod_name} --image={image_name} --port={port}
- kubectl run nginx-pod --image=nginx:1.22.1 --port=80 --dry-run=client -o yaml > nginx-pod.yaml (dry run to show what happend next when we run this command)
- kubectl delete pod {pod_name}
- kubectl replace --force -f {deployment_file} --> reapply deployment file, used for fix wrong or invalid template
- kubectl get replicasets (or kubectl get rs)
- kubectl get replicaset {replicaset_name} -o [yaml,json]
- kubectl run admitted --image=nginx --image-pull-policy=IfNotPresent
- kubectl run mutated --image=nginx --image-pull-policy=IfNotPresent
#Grep selector for specific service (For getting pods related to service)
- kubectl describe svc pod-hello | grep -i selector
#Grep endpoint (IP address and exposed port of pods related to service)
- kubectl get ep
#Edit service
- kubectl edit svc {name_of_service}

Objects in kubernetes:
  - cluster --> group of nodes for kubernetes infrastructure
  - node --> can be physic machine or virtual machine
    - control plane
      - api server
      - controller manager
      - scheduler
      - kubelet
      - kube-proxy
    - worker
      - kubelet
      - kube-proxy
  - pods --> smallest unit in kubernetes
  - namespace --> sub-cluster
  - labels --> tagging for objects in kubernetes
    - selector
      - equality-based selector --> equals
      - set-based selector --> in or not in, !app (no label key app)
  - replication controller --> ensure number of replica based on desired state of application (legacy type)
    - only support equality-based selector
  - Deployment --> manage creation, update, and deletion of pods. Automatically create replicaset.
    - Support update and rolling back (RollingUpdate strategy)
    - Deploymentcontroller is part of control plane controller manager
  - Replicaset --> control lifecycle of multiple replica of pod for HA
    - support self healing
    - support equality-based and set-based selector
    - Do not support update and rolling back
  - service :
    - Group logical of pods that can be chosen by label and selector
    - Type of services :
        - ClusterIP
            - default service type
            - Can be accessed within cluster only
        - Nodeport
            - High port, dynamically picked port number from 30000-32767
            - Example, if we mapping port 32233 to frontend-svc, it will be directed to clusterIP of frontend-svc
            - Useful when port accessed from external user, and then proxied internally to clusterIP
        - LoadBalancer

  - kube-proxy
    - Daemon each cluster node, watching API server in control plane for addition, removal or update of service and endpoints
    - Build redundantly with iptables
    - Load balancing to endpoints/pods
    - If traffic policies not assigned, service will direct or routed traffic randomly for load balancing

  - Traffic Policies :
    - Make sure traffic routed based on policy / not randomly
    - Applied for internal traffic from cluster of external traffic from client
    - Type of traffic policies :
        - cluster
            - default behavior or traffic policies not assigned. Target all endpoints of services in load balancing
        - local
            - isolates number of pods or endpoints in service on same node in load balancing traffic
            - specific node that capture inbound traffic (Nodeport)

  - Service discovery
    - Environment variables
    - DNS


Users in kubernetes authentication :
  - Normal Users
  - Service Account

Authentication modules :
  - X509 Client certificates
  - Static token file
  - Bootstrap token
  - Service account tokens
  - OpenID Connect tokens
  - Webhook Token Authentication
  - Authenticating proxy

Authorization modes : 
  - Node
    --> Used for authorization for kubelet to read operation to node, service, endpoint and write operation to node, service, endpoint, pods
  - Attribute Based Access Control (ABAC)
    --> Combine Attribute with policy.
    --> For specify ABAC mode ,  --authorization-mode=ABAC and --authorization-policy-file=PolicyFile.json
  - Webhook
    --> Integrate to third party
  - Role-Based Access Control (RBAC)
    - Restric based on operations or group of operations (Role), assigned to Users
    - Kind of roles
      - Role
        - Role grant to specific resources within specific namespace
      - ClusterRole
        - Same as role, but scope is cluster wide

Admission control : 
  - Specify granular Access control policies, ex : 
    - allowing priviledged container
    - checking on quota resources
    - Activated using parameter --enable-admission-plugins=NamespaceLifecycle,ResourceQuota,PodSecurity,DefaultStorageClass
  - Type of admission controllers :
    - Limitranger (Scope per individual pod or container)
      - Ensures that pods and containers have resource limits defined.
      - If LimitRange resources are defined in a namespace, LimitRanger checks whether the requests (for CPU and memory) in a pod fall within those limits.
      - If requests or limits are missing, it can set default values or deny the request if it's out of bounds.
    - ResourceQuota (Scope per namespace)
      - Enforces resource quotas in a namespace, limiting the total resource consumption for pods, services, or other Kubernetes objects within that namespace.
      - It ensures that resources (like CPU, memory, or object counts) do not exceed predefined limits.
      - If a request would exceed the quota, the admission controller denies it.
    - DefaultStorageClass
      - Ensures that persistent volume claims (PVCs) have a default storage class if none is specified.
      - When a PVC is created without specifying a storage class, the DefaultStorageClass admission controller automatically assigns the default storage class if one is available.
      - This simplifies the PVC creation process and ensures that storage is dynamically provisioned when needed.
    - AlwaysPullImages
      - Forces the imagePullPolicy of all containers to Always, regardless of what is specified in the pod specification.
      - This ensures that the latest image is always pulled from the registry, preventing accidental use of cached or old images.
      - Particularly useful in multi-tenant clusters where you want to prevent image reuse that may lead to security issues.

    